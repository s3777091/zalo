import aiohttp
import logging
import io
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)

class OcrService:
    _easyocr_reader = None

    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key
        self.api_endpoint = "https://api.ocr.space/parse/image"
    #     self._initialize_local_reader()

    # @classmethod
    # def _initialize_local_engine(cls):
    #     if cls._local_ocr_engine is None:
    #         try:
    #             cls._local_ocr_engine = PaddleOCR(
    #                 lang='vi',
    #                 use_angle_cls=False,
    #                 show_log=False,
    #                 use_gpu=False
    #             )
    #             logger.info("PaddleOCR engine initialized successfully.")
    #         except Exception as e:
    #             logger.error(f"Failed to initialize PaddleOCR engine: {e}")
    #             cls._local_ocr_engine = None

    async def _send_api_request(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        if not self.api_key:
            raise ValueError("API key must be provided for API-based OCR.")
            
        headers = {"apikey": self.api_key}

        try:
            async with aiohttp.ClientSession() as session:
                async with session.post(self.api_endpoint, headers=headers, data=payload) as response:
                    response.raise_for_status()
                    return await response.json()
        except Exception as e:
            logger.error(f"API request failed: {e}")
            return {
                "IsErroredOnProcessing": True,
                "ErrorMessage": [str(e)],
                "ErrorDetails": "",
                "OCRExitCode": 99
            }

    async def ocr_from_url_api(
        self,
        url: str,
        language: str = 'vnm',
        ocr_engine: int = 2,
        is_overlay_required: bool = False,
        **kwargs
    ) -> Dict[str, Any]:
        payload = {
            "url": url,
            "language": language,
            "OCREngine": ocr_engine,
            "detectOrientation": True,
            "scale": True,
            "isOverlayRequired": is_overlay_required,
            **kwargs
        }
        return await self._send_api_request(payload)

    # async def ocr_from_url_local(self, url: str) -> Dict[str, Any]:
    #     if self._local_ocr_engine is None:
    #         return {
    #             "IsErroredOnProcessing": True, "ErrorMessage": ["PaddleOCR engine is not available."],
    #             "ErrorDetails": "Check logs for initialization errors.", "OCRExitCode": 98
    #         }

    #     try:
    #         async with aiohttp.ClientSession() as session:
    #             async with session.get(url, timeout=20) as response:
    #                 response.raise_for_status()
    #                 image_bytes = await response.read()
            
    #         logger.info(f"Processing image from URL using local PaddleOCR.")
    #         result = self._local_ocr_engine.ocr(image_bytes, cls=False)
            
    #         extracted_texts = []
    #         if result and result[0]:
    #             extracted_texts = [line[1][0] for line in result[0]]

    #         full_text = '\n'.join(extracted_texts).strip()
            
    #         logger.info(f"PaddleOCR extracted {full_text} text segments.")

    #         return {
    #             "ParsedResults": [{"ParsedText": full_text, "TextOverlay": {
    #                 "Lines": [{"LineText": line, "Words": []} for line in extracted_texts],
    #                 "HasOverlay": False, "Message": "Overlay data is not generated by this local method."
    #             }}],
    #             "OCRExitCode": 1, "IsErroredOnProcessing": False, "ErrorMessage": [], "ErrorDetails": ""
    #         }

    #     except Exception as e:
    #         logger.error(f"Error during local OCR processing for URL {url}: {e}", exc_info=True)
    #         return {
    #             "IsErroredOnProcessing": True, "ErrorMessage": [str(e)],
    #             "ErrorDetails": "", "OCRExitCode": 99
    #         }